<head><meta charset="UTF-8"></head>

##
1. python -c 在终端里结果以字符串形式输出 (python -c "print 'A'*64+'B'" | ./pwn1)
2. 直接运行py文件: 文件开头加上`#!/usr/bin/env python3`,并`$ chmod a+x hello.py`，则`./hello.py`
3. 中文乱码的解决: 文本编辑器正在使用UTF-8 without BOM编码；文件开头声明`# -*- coding: utf-8 -*-`

##
### 格式化
```
'Hello, %s' % 'world'
'Hi, %s, you have $%d.' % ('Michael', 1000000)
print('n1表示为十六进制字符串：{}，n2表示为十六进制字符串：{}'.format(hex(n1),hex(n2)))
```
### 格式化时间
关于parser
字符串可以很随意，可以用时间日期的英文单词，可以用横线、逗号、空格等做分隔符。
没指定时间默认是0点，没指定日期默认是今天，没指定年份默认是今年。
>>from dateutil.parser import parse
>>parse("Wed, Nov 12")
datetime.datetime(2013, 11, 12, 0, 0)
>>parse("2013-08-20")
datetime.datetime(2013, 8, 20, 0, 0)
>>parse("20130820")
datetime.datetime(2013, 8, 20, 0, 0)
>>parse("2013,08,20")
datetime.datetime(2013, 8, 20, 0, 0)
>>parse("08,20")
datetime.datetime(2013, 8, 20, 0, 0)
>>parse("12:00:00")
datetime.datetime(2013, 8, 20, 12, 0)
>>parse("this is the wonderful moment 12:00:00,I feel good",fuzzy=True)#fuzzy开启模糊匹配，过滤掉无法识别的时间日期字符
datetime.datetime(2013, 8, 20, 12, 0)
### 函数
#### 数据类型检查
数据类型检查可以用内置函数isinstance()实现：
```
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
```
#### 返回多个值
```
def fun():
    return x,y
    #返回值其实是tuple

a,b=fun()
```
### 类
1. 作用域: self代表实例，self.**是实例变量；在类中但在类的函数外的***是类变量；在类的函数中的***是局部变量。
2. 全局变量：global ，不要类或实例. 。

### 错误处理
1. try...except...else...finally
```
try:
    print('try...')
    r = 10 / 0        #如果有错误，则后面代码不执行，跳去错误处理
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
except ValueError as e:
    print('ValueError:', e)
else:
    print('no error')  #当没有错误发生时，会自动执行else语句；若有错误，则不执行else
finally:
    print('finally...') #有或无错误，都会执行finally
print('END')
```
2. 记录错误(logging)
如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。若捕获错误，则程序可以继续执行下去。
```
try:
        bar('0')
    except Exception as e:
        logging.exception(e)
# 同样是出错，但程序打印完错误信息后会继续执行，并正常退出; 通过配置，logging还可以把错误记录到日志文件里
```
3. 自己抛出错误(raise)
1. 如果要抛出错误，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例：
```
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
```
2. 捕获错误，打印一个ValueError!后，又把错误通过raise语句抛出去了。
```

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise # 抛出
        # 其它情况下，还可raise ValueError('input error!')
bar()
```



## 杂
1. 「argv」是「argument variable」参数变量的简写形式，一般在命令行调用的时候由系统传递给程序。
这个变量其实是一个List列表，argv[0] 一般是被调用的脚本文件名或全路径，和操作系统有关，argv[1]和以后就是传入的数据了。
2. strip() 去除开始和末尾的空格本身，回车\r，换行\n，制表符\t， 换页符\f
3. str.splitlines([keepends]) 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。




